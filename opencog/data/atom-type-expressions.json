{
  "generalized": {
    "cognitive_domain": {
      "name": "Cognitive Domain Atom (CD)",
      "expression": "CD(d) = \u27e8\u03a9_d, \u03a3_d, \u03a8_d, \u03a6_d\u27e9",
      "components": {
        "\u03a9_d": "Task universe for domain d - set of all tasks in the domain",
        "\u03a3_d": "Subcategory partitioning - refined specialization of \u03a9_d",
        "\u03a8_d": "Cognitive processes - mental operations required",
        "\u03a6_d": "Performance metrics - evaluation functions"
      },
      "semantics": "A cognitive domain atom represents a fundamental area of cognitive capability, characterized by its task universe, internal structure, required processes, and performance measures."
    },
    "language_paradigm": {
      "name": "Language Paradigm Atom (LP)",
      "expression": "LP(p) = \u27e8\u039b_p, \u03a0_p, \u0398_p, \u039e_p\u27e9",
      "components": {
        "\u039b_p": "Language set - programming languages in paradigm p",
        "\u03a0_p": "Paradigmatic features - defining characteristics",
        "\u0398_p": "Computational model - execution semantics",
        "\u039e_p": "Domain applicability - fitness for cognitive domains"
      },
      "semantics": "A language paradigm atom represents a fundamental approach to programming, characterized by its language membership, defining features, computational model, and effectiveness across cognitive domains."
    }
  },
  "cognitive_domains": {
    "symbolic_reasoning": {
      "name": "symbolic_reasoning",
      "category": "cognitive_domain",
      "description": "Logic, theorem proving, constraint satisfaction, formal reasoning",
      "properties": {},
      "relationships": {
        "complements": [
          "knowledge_representation",
          "planning_problem_solving"
        ],
        "requires": [
          "pattern_recognition"
        ],
        "enables": [
          "uncertainty_reasoning"
        ]
      },
      "expression": "CD(symbolic_reasoning) = \u27e8\u03a9_symbolic_reasoning, \u03a3_symbolic_reasoning, \u03a8_symbolic_reasoning, \u03a6_symbolic_reasoning\u27e9"
    },
    "pattern_recognition": {
      "name": "pattern_recognition",
      "category": "cognitive_domain",
      "description": "Search algorithms, pattern matching, classification",
      "properties": {},
      "relationships": {
        "complements": [
          "machine_learning",
          "perception_motor"
        ],
        "requires": [],
        "enables": [
          "symbolic_reasoning",
          "natural_language"
        ]
      },
      "expression": "CD(pattern_recognition) = \u27e8\u03a9_pattern_recognition, \u03a3_pattern_recognition, \u03a8_pattern_recognition, \u03a6_pattern_recognition\u27e9"
    },
    "knowledge_representation": {
      "name": "knowledge_representation",
      "category": "cognitive_domain",
      "description": "Data structures, graphs, semantic networks, ontologies",
      "properties": {},
      "relationships": {
        "complements": [
          "symbolic_reasoning",
          "natural_language"
        ],
        "requires": [],
        "enables": [
          "planning_problem_solving"
        ]
      },
      "expression": "CD(knowledge_representation) = \u27e8\u03a9_knowledge_representation, \u03a3_knowledge_representation, \u03a8_knowledge_representation, \u03a6_knowledge_representation\u27e9"
    },
    "machine_learning": {
      "name": "machine_learning",
      "category": "cognitive_domain",
      "description": "Statistical methods, optimization, neural networks",
      "properties": {},
      "relationships": {
        "complements": [
          "uncertainty_reasoning",
          "pattern_recognition"
        ],
        "requires": [
          "knowledge_representation"
        ],
        "enables": [
          "perception_motor"
        ]
      },
      "expression": "CD(machine_learning) = \u27e8\u03a9_machine_learning, \u03a3_machine_learning, \u03a8_machine_learning, \u03a6_machine_learning\u27e9"
    },
    "natural_language": {
      "name": "natural_language",
      "category": "cognitive_domain",
      "description": "String manipulation, parsing, text analysis, NLP",
      "properties": {},
      "relationships": {
        "complements": [
          "knowledge_representation",
          "symbolic_reasoning"
        ],
        "requires": [
          "pattern_recognition"
        ],
        "enables": [
          "meta_learning"
        ]
      },
      "expression": "CD(natural_language) = \u27e8\u03a9_natural_language, \u03a3_natural_language, \u03a8_natural_language, \u03a6_natural_language\u27e9"
    },
    "planning_problem_solving": {
      "name": "planning_problem_solving",
      "category": "cognitive_domain",
      "description": "Heuristic search, game playing, puzzle solving, planning",
      "properties": {},
      "relationships": {
        "complements": [
          "symbolic_reasoning",
          "uncertainty_reasoning"
        ],
        "requires": [
          "knowledge_representation"
        ],
        "enables": [
          "cognitive_architecture"
        ]
      },
      "expression": "CD(planning_problem_solving) = \u27e8\u03a9_planning_problem_solving, \u03a3_planning_problem_solving, \u03a8_planning_problem_solving, \u03a6_planning_problem_solving\u27e9"
    },
    "uncertainty_reasoning": {
      "name": "uncertainty_reasoning",
      "category": "cognitive_domain",
      "description": "Probabilistic methods, Bayesian reasoning, fuzzy logic",
      "properties": {},
      "relationships": {
        "complements": [
          "machine_learning",
          "planning_problem_solving"
        ],
        "requires": [
          "symbolic_reasoning"
        ],
        "enables": []
      },
      "expression": "CD(uncertainty_reasoning) = \u27e8\u03a9_uncertainty_reasoning, \u03a3_uncertainty_reasoning, \u03a8_uncertainty_reasoning, \u03a6_uncertainty_reasoning\u27e9"
    },
    "cognitive_architecture": {
      "name": "cognitive_architecture",
      "category": "cognitive_domain",
      "description": "Concurrent systems, distributed computing, agent systems, emergence",
      "properties": {},
      "relationships": {
        "complements": [
          "planning_problem_solving"
        ],
        "requires": [
          "knowledge_representation"
        ],
        "enables": [
          "meta_learning"
        ]
      },
      "expression": "CD(cognitive_architecture) = \u27e8\u03a9_cognitive_architecture, \u03a3_cognitive_architecture, \u03a8_cognitive_architecture, \u03a6_cognitive_architecture\u27e9"
    },
    "perception_motor": {
      "name": "perception_motor",
      "category": "cognitive_domain",
      "description": "Image processing, signal processing, robotics, sensorimotor",
      "properties": {},
      "relationships": {
        "complements": [
          "machine_learning",
          "pattern_recognition"
        ],
        "requires": [],
        "enables": []
      },
      "expression": "CD(perception_motor) = \u27e8\u03a9_perception_motor, \u03a3_perception_motor, \u03a8_perception_motor, \u03a6_perception_motor\u27e9"
    },
    "meta_learning": {
      "name": "meta_learning",
      "category": "cognitive_domain",
      "description": "Self-improvement, code generation, reflection, introspection",
      "properties": {},
      "relationships": {
        "complements": [
          "natural_language",
          "symbolic_reasoning"
        ],
        "requires": [
          "cognitive_architecture"
        ],
        "enables": []
      },
      "expression": "CD(meta_learning) = \u27e8\u03a9_meta_learning, \u03a3_meta_learning, \u03a8_meta_learning, \u03a6_meta_learning\u27e9"
    }
  },
  "language_paradigms": {
    "imperative": {
      "name": "imperative",
      "category": "language_paradigm",
      "description": "Imperative programming with explicit state changes",
      "properties": {},
      "relationships": {
        "contrasts": [
          "functional",
          "logic"
        ],
        "extends_to": [
          "object_oriented",
          "scripting"
        ],
        "composes_with": [
          "concurrent"
        ]
      },
      "expression": "LP(imperative) = \u27e8\u039b_imperative, \u03a0_imperative, \u0398_imperative, \u039e_imperative\u27e9"
    },
    "object_oriented": {
      "name": "object_oriented",
      "category": "language_paradigm",
      "description": "Object-oriented programming with encapsulation and inheritance",
      "properties": {},
      "relationships": {
        "contrasts": [
          "functional"
        ],
        "extends_to": [
          "multi_paradigm"
        ],
        "composes_with": [
          "imperative",
          "scripting"
        ]
      },
      "expression": "LP(object_oriented) = \u27e8\u039b_object_oriented, \u03a0_object_oriented, \u0398_object_oriented, \u039e_object_oriented\u27e9"
    },
    "functional": {
      "name": "functional",
      "category": "language_paradigm",
      "description": "Functional programming with immutability and higher-order functions",
      "properties": {},
      "relationships": {
        "contrasts": [
          "imperative",
          "object_oriented"
        ],
        "extends_to": [
          "multi_paradigm"
        ],
        "composes_with": [
          "logic",
          "concurrent"
        ]
      },
      "expression": "LP(functional) = \u27e8\u039b_functional, \u03a0_functional, \u0398_functional, \u039e_functional\u27e9"
    },
    "logic": {
      "name": "logic",
      "category": "language_paradigm",
      "description": "Logic programming with declarative rules",
      "properties": {},
      "relationships": {
        "contrasts": [
          "imperative"
        ],
        "extends_to": [
          "multi_paradigm"
        ],
        "composes_with": [
          "functional"
        ]
      },
      "expression": "LP(logic) = \u27e8\u039b_logic, \u03a0_logic, \u0398_logic, \u039e_logic\u27e9"
    },
    "concurrent": {
      "name": "concurrent",
      "category": "language_paradigm",
      "description": "Languages designed for concurrent/parallel programming",
      "properties": {},
      "relationships": {
        "contrasts": [],
        "extends_to": [
          "multi_paradigm"
        ],
        "composes_with": [
          "functional",
          "imperative"
        ]
      },
      "expression": "LP(concurrent) = \u27e8\u039b_concurrent, \u03a0_concurrent, \u0398_concurrent, \u039e_concurrent\u27e9"
    },
    "scripting": {
      "name": "scripting",
      "category": "language_paradigm",
      "description": "Dynamic scripting languages",
      "properties": {},
      "relationships": {
        "contrasts": [
          "system"
        ],
        "extends_to": [
          "multi_paradigm"
        ],
        "composes_with": [
          "object_oriented",
          "functional"
        ]
      },
      "expression": "LP(scripting) = \u27e8\u039b_scripting, \u03a0_scripting, \u0398_scripting, \u039e_scripting\u27e9"
    },
    "system": {
      "name": "system",
      "category": "language_paradigm",
      "description": "Systems programming languages with low-level control",
      "properties": {},
      "relationships": {
        "contrasts": [
          "scripting"
        ],
        "extends_to": [],
        "composes_with": [
          "imperative"
        ]
      },
      "expression": "LP(system) = \u27e8\u039b_system, \u03a0_system, \u0398_system, \u039e_system\u27e9"
    },
    "scientific": {
      "name": "scientific",
      "category": "language_paradigm",
      "description": "Languages optimized for scientific computing",
      "properties": {},
      "relationships": {
        "contrasts": [],
        "extends_to": [
          "multi_paradigm"
        ],
        "composes_with": [
          "functional",
          "imperative"
        ]
      },
      "expression": "LP(scientific) = \u27e8\u039b_scientific, \u03a0_scientific, \u0398_scientific, \u039e_scientific\u27e9"
    },
    "multi_paradigm": {
      "name": "multi_paradigm",
      "category": "language_paradigm",
      "description": "Multi-paradigm languages supporting multiple styles",
      "properties": {},
      "relationships": {
        "contrasts": [],
        "extends_to": [],
        "composes_with": [
          "imperative",
          "functional",
          "object_oriented"
        ]
      },
      "expression": "LP(multi_paradigm) = \u27e8\u039b_multi_paradigm, \u03a0_multi_paradigm, \u0398_multi_paradigm, \u039e_multi_paradigm\u27e9"
    }
  }
}